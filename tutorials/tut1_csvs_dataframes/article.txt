Intro

Financial analysis using Python usually involves some kind of series, and running some kind of computation on that series. When approaching the task, you are likely to encounter Comma Separated Value (.csv) files. These files can hold value for tables.
But alone, a table is not much help to us. We need some kind of way to look through the table, process the data, and perform computations on it's values. This is where Dataframes come in: A Dataframe is a computer object which once loaded, stores all the data of the .csv file in a much more useful way. This is the starting point for your technical analysis in Python.

Setup:

To start, I will assume:
You are familiar with basic object oriented programming coding concepts
You are familiar with Git, that is, you can fetch a repository
You are familiar with Python development, that is, you can create and run a script, using the terminal
You will also need to have the Pandas library installed (pip install pandas).

Explaining CSVs

First, let's learn a little bit about CSVs. 

Lines represent a "row" of data, values are separated with a comma in between each value.

Example:
05898, AWR584, 6/12/1978
02785, BLH967, 4/5/2001

Here we see 2 entries, with 3 values associated with each entry. Each entry (line in the file) should have the same number of values (rows, or number of commas)

You might recognise the last value in this series as a calendar date. But what if you don't know what the other 2 columns represent?
Unfortunately, there's no real way of knowing, unless you can find the source or make deductions yourself.

Therefore, it's good practice to include labels in a CSV. You can do this by reserving the first line of the file for a series of data labels:

Example:
Customer ID, Vehicle Registration, Date of Birth


Now we can see that the first value in each line is that entries Customer ID, the second is their Vehicle rego, and the last entry is Date of Birth. You may sometimes find CSVs which do not contain this line, and just start right away with data.

To make a well formed CSV to store this data, just put your line of labels at the top, and your data below. Make sure there are no empty lines, or some programs may have trouble working with your .csv file.

Example:

Customer ID, Vehicle Registration, Date of Birth
05898, AWR584, 6/12/1978
02785, BLH967, 4/5/2001

Here's an example .csv of an AAPL daily price record:

    Date,Code,Open,High,Low,Close,Volume,Value,Trans,Adj,Exchange,DataSource
    01-Feb-2018,AAPL,0.4179,0.4216,0.4169,0.4194,189537940,7959426098,309149,0.25,NAS,USXE
    02-Feb-2018,AAPL,0.415,0.417,0.4002,0.4012,347904496,14172890566,603830,0.25,NAS,USXE
    05-Feb-2018,AAPL,0.3977,0.4097,0.39,0.3912,291049384,11673630072,528524,0.25,NAS,USXE
    06-Feb-2018,AAPL,0.3871,0.4093,0.385,0.4076,273001160,10896333105,506752,0.25,NAS,USXE
    07-Feb-2018,AAPL,0.4077,0.4085,0.3977,0.3988,209426552,8435900928,341979,0.25,NAS,USXE

I'll use this example to show you how to process this into a dataframe, and return some values.

Give instructions on fetching the sample code and price data from a repository

Open example.py, or create a new python file with the usual script boilerplate:
Check your target CSV is in the same directory as your script.

Opening the CSV and creating the dataframe can be done in two lines of code:

    import pandas as pd

    filename = "data.csv"
    df = pd.read_csv(filename)

Create graphic explaining each part of the line of code: name for the dataframe, method call, string of filename
Mention in a few words that the first line is better practice for expanding the script for multiple files

Exploring dataframes

The new dataframe has many useful methods and properties, some of which I will explain here:

.head() Will return the first few rows. Useful for checking that a file has been correctly processed into a dataframe.
.shape returns rows x columns in format
.columns  will return just the number of columns
.info() shows a summary of the data types in the dataframe.

Example:

    import pandas as pd

    filename = "data.csv"
    df = pd.read_csv(filename)

    print("\nPreview of data:")
    print(df.head())

    print("\nColumn names:")
    print(df.columns.tolist())

    print("\nShape (rows, columns):")
    print(df.shape)

    print("\nData types and memory info:")
    print(df.info())



5. Accessing Data

Once your data is loaded into a dataframe, you can access specific columns, rows, or individual cells. These are the most common methods you’ll use:

df["column_name"]
Returns a single column as a Series.

df[["col1", "col2"]]
Returns multiple columns as a DataFrame.

df.loc[row_label]
Selects a row by its label (index name).

df.iloc[row_position]
Selects a row by its position (starting from 0).

df.loc[row_label, "col_name"]
Selects a specific cell by row label and column name.

df.iloc[row_position, col_position]
Selects a specific cell by row and column position.

Example:

    import pandas as pd

    filename = "data.csv"
    df = pd.read_csv(filename)

    print("\nAccessing a single column:")
    print(df["Close"]) # Use the column label as defined in the first line of the CSV

    print("\nAccessing multiple columns:")
    print(df[["Date", "Close"]])

    print("\nAccessing rows:")
    print(df.loc[0])      # Use zero based indexing 

    print("\nAccessing specific cells:")
    print(df.loc[0, "Close"])   # Returns the value  of the "Close" column for row 0
    print(df.iloc[0, 4])        # Returns the value  of the 5th column for row 0


Selecting and Processing Data

Once you know how to access specific parts of a DataFrame, you can start filtering, sorting, and modifying your data. These operations are the foundation of any data analysis in Python.

df[df["col_name"] > value]
Filters rows based on a condition. Returns only rows where the condition is true.

df.sort_values("col_name")
Sorts the DataFrame by the values in a given column. Add ascending=False to reverse the order.

df["new_col"] = df["col1"] + df["col2"]
Creates a new column from existing ones.

Example:

    import pandas as pd

    filename = "data.csv"
    df = pd.read_csv(filename)

    print("\nFiltering rows where Volume > 200000000:")
    print(df[df["Volume"] > 200000000])

    print("\nSorting data by Close price (descending):")
    print(df.sort_values("Close", ascending=False).head())

    print("\nCreating a new column for daily range (High - Low):")
    df["Range"] = df["High"] - df["Low"]
    print(df[["Date", "High", "Low", "Range"]].head())

7. Other useful stuff

These are some additional methods you’ll frequently use when inspecting or cleaning your data.

.dropna()
Removes rows with missing values (NaN).

.fillna(value)
Replaces missing values with a specified value.

.describe()
Displays summary statistics for numeric columns (count, mean, std, min, max, etc.).

.value_counts("col_name")
Counts unique values in a column.

.unique()
Lists all unique values in a Series (single column).

.nunique()
Counts the number of unique values per column.

.sample(n=5)
Returns a random sample of rows (useful for large datasets).

.head(n) and df.tail(n)
View the first or last n rows.


8. Saving Changes

Once you’ve finished processing or cleaning your data, you’ll often want to save the modified DataFrame for later use or sharing.

Write the DataFrame to a CSV file
df.to_csv("new_data.csv", index=False)


Saves the DataFrame as a CSV file.
Setting index=False prevents pandas from writing the row index as an extra column in the output file.

Write to Excel
df.to_excel("output.xlsx", index=False)


Saves the DataFrame to an Excel file.
You can specify a sheet name using sheet_name="Sheet1".

Save only selected columns
df[["Date", "Close", "Volume"]].to_csv("selected_data.csv", index=False)


Writes only the specified columns to the new file.

Append data to an existing CSV
df.to_csv("data.csv", mode="a", header=False, index=False)


Appends new rows to an existing CSV file instead of overwriting it.
Make sure the column order matches the existing file to avoid misalignment.

Best Practice:
When saving processed data, it’s good practice to:

Keep a backup of the original dataset.

Use clear filenames that describe the data’s purpose or date (e.g. cleaned_prices_2025.csv).

Verify saved files by reopening them in pandas or a spreadsheet to ensure formatting and column alignment are correct.